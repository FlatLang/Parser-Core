package flat/parser

import flat/datastruct/list/Stack
import flat/ast
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

import static flat/colorizer/Colorizer

class {
  static Logger log = Logger(ParseEngine.class)

  var Int lastLineNumber = 0

  public construct(
    private ParserBase rootParser,
    visible var ParseContext context,
    private var Stream stream
  ) {
    context.pushScope(rootParser, FileNode())
  }

  public consume(Token token) {
    match token.type {
      Token.Type.COMMENT =>
      Token.Type.WS => return
    }

    if (token.location && token.location.lineNumber > lastLineNumber) {
      lastLineNumber = token.location.lineNumber
      log.debugFunc({"line #{magenta(token.location.lineNumber.toString())} col #{magenta(token.location.column.toString())}"})
    }

    context.tokens.add(token)

    matchToken(token)
  }

  public end() {
    generateNode(rootParser)
  }

  public matchToken(Token token) {
    ParseEngine.log.debugFunc({"Matching token: '#{token.value}' (line #{magenta(token.location?.lineNumber.toString())}) (tokens: [#{context.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]) #{green(rootParser.class.name)}"})

    if (let match = rootParser.match(token, context)) {
      ParseEngine.log.debugFunc({"Matched: #{rootParser.class.name}"})
    } else if (rootParser.matcher.partial) {
      ParseEngine.log.debugFunc({"Partial match: #{rootParser.class.name}"})
    } else {
      invalidTokens()
    }
  }

  public generateNode(ParserBase parser) -> Node {
    ParseEngine.log.debugFunc({"Generating node for parser: #{parser.class.name}"})
    let node = parser.generateNode(context, parser.lastMatch)

    if (node) {
      stream.emit("data", node)$
    }

    parseChildNodes(parser)

    return node
  }

  public parseChildNodes(ParserBase parser) {
    if (let nodeMatches = parser.getChildNodeTokenMatches(context, parser.lastMatch)) {
      nodeMatches.forEach((nodeMatch) => {
        ParseEngine.log.debugFunc({"Parsing child nodes for match: [#{nodeMatch.childMatches.map(m => m.parser.class.name).join(", ")}]"})
        nodeMatch.generateNodes(context).forEach((node) => {
          ParseEngine.log.debugFunc({"Parsed child node: #{node.class.name}"})
          stream.emit("data", node)$
        })
      })
    }
  }

  public invalidTokens() {
    invalidTokensError(context.tokens)
  }

  public invalidTokensError(Token[] tokens) {
    ParseEngine.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]. Resetting tokens. Parser #{context.currentParser.class.name}"})
    if (tokens.isNotEmpty && tokens.first.location) {
      if (tokens.count == 1) {
        let token = tokens.first

        ParseEngine.log.errorFunc({"Could not parse token '#{token.value}' at #{token.location.lineNumber}:#{token.location.column}"})
      } else {
        ParseEngine.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}] at #{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"})
      }
    }
  }
}