package flat/parser

import flat/datastruct/list/Stack
import flat/ast
import flat/compiler/models/Token
import flat/io/File
import flat/log/Logger
import flat/stream/Stream

import static flat/colorizer/Colorizer

class {
  static Logger log = Logger(ParseEngine.class)

  var Int lastLineNumber = 0

  public construct(
    private ParserBase rootParser,
    visible var ParseContext context,
    private var Stream stream
  ) {
    rootParser.context = context
  }

  public consume(Token token) {
    if (stream.closed) return

    match token.type {
      Token.Type.COMMENT =>
      Token.Type.WS => return
    }

    if (token.location && token.location.lineNumber > lastLineNumber) {
      lastLineNumber = token.location.lineNumber
      log.debugFunc({"line #{magenta(token.location.lineNumber.toString())} col #{magenta(token.location.column.toString())}"})
    }

    context.tokens.add(token)

    matchToken(token)
  }

  public end() {
    log.debugFunc({"Reached end of parsing"})
    if (rootParser.lastMatch) {
      rootParser.generateNodes().forEach({
        stream.emit("data", _)$
      })
    }

    stream.emit("close")$
  }

  public matchToken(Token token) {
    ParseEngine.log.debugFunc({"Matching token: '#{token.value}' (line #{magenta(token.location?.lineNumber.toString())}) (tokens: [#{context.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]) #{green(rootParser.class.name)}"})

    if (let match = rootParser.match(token)) {
      ParseEngine.log.debugFunc({"Matched: #{rootParser.class.name}"})
    } else if (rootParser.matcher.partial) {
      ParseEngine.log.debugFunc({"Partial match: #{rootParser.class.name}"})
    } else {
      invalidTokens()
    }
  }

  public invalidTokens() {
    invalidTokensError(context.tokens)
  }

  public invalidTokensError(Token[] tokens) {
    ParseEngine.log.debugFunc({"Could not parse tokens [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]. Resetting tokens. Parser #{context.currentParser.class.name}"})
    if (tokens.isNotEmpty && tokens.first.location) {
      if (tokens.count == 1) {
        let token = tokens.first

        ParseEngine.log.errorFunc({"Could not parse token '#{token.value}' at #{token.location.lineNumber}:#{token.location.column}"})
      } else {
        ParseEngine.log.errorFunc({"Could not parse tokens [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}] at #{tokens.first.location.lineNumber}:#{tokens.first.location.column}-#{tokens.last.endLineNumber}:#{tokens.last.endColumn}"})
      }
    }
    stream.emit("quit")$
  }
}