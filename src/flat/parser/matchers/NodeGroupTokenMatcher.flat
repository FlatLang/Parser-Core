package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeGroupTokenMatcher.class)

  NodeGroupTokenPattern pattern

  var TokenMatch[] childMatches = TokenMatch[]
  var NodeGroupTokenMatch groupMatch
  var ParserBase[] currentParsers
  var NodeTokenMatcher currentMatcher
  var Bool addedCurrentMatch = false
  var Bool attemptingBacktrackMatch = false

  override public match(Token token, ParseContext context = null) -> NodeGroupTokenMatch {
    if (!currentParsers) {
      resetCurrentParsers(context)
    }
    if (!currentMatcher) {
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    }

    return tokenMatches.add(doMatch(token, context))
  }

  doMatch(Token token, ParseContext context) -> NodeGroupTokenMatch => null {
    if (disqualified) return null

    tokens.add(token)

    log.traceFunc({"|
      Matching token '#{green(token.value)}' #{magenta(token.location?.lineNumber.toString())}:#{magenta(token.location?.column.toString())}:
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
      |"})

    if (let match = currentMatcher.match(token, context)) {
      if (match.childMatches.isEmpty) {
        log.traceFunc({"Partial match for current matcher"})
        return null
      }
      log.traceFunc({"Successful match with current matcher. Parser: #{match.parser.class.name}"})
      let wasDisqualified = currentMatcher.disqualified
      if (currentMatcher.disqualified) {
        log.traceFunc({"Current matcher is disqualified. Returning match and switching to new current matcher"})
        resetCurrentParsers(context)
        currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
        complete = true
      } else {
        log.traceFunc({"Current matcher is partial. Returning match and continuing"})
      }

      valid = true

      if (addedCurrentMatch) {
        log.traceFunc({"Replacing last match"})
        childMatches.replaceLast(match)
      } else {
        log.traceFunc({"Adding last match"})
        childMatches.add(match)
      }

      if (wasDisqualified) {
        addedCurrentMatch = false
      } else {
        addedCurrentMatch = true
      }

      if (groupMatch) {
        log.traceFunc({"|
          Adding to current groupMatch
            current groupMatch.tokens: [#{groupMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            match.tokens: [#{match.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          |"})
        groupMatch = groupMatch.copy(
          tokens: pattern.includeTokens ? childMatches.flatMap({ _.tokens }) : Token[],
          childMatches: childMatches.copy()
        )
      } else {
        log.traceFunc({"|
          Creating new groupMatch from tokens:
            match.tokens: [#{match.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          |"})
        groupMatch = NodeGroupTokenMatch(
          tokens: pattern.includeTokens ? match.tokens.copy() : Token[],
          label: pattern.label,
          childMatches: childMatches.copy()
        )
      }

      if (groupMatch.tokens.count == tokens.count) {
        log.traceFunc({"|
          Returning group match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          |"})

        return groupMatch
      }

      if (let backtrack = attemptBacktrackMatch(context)) {
        return backtrack
      }

      if (!partial) {
        log.traceFunc({"|
          Backtrack was not partial. Returning group match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          |"})

        return groupMatch
      }
    } else if (currentMatcher.partial) {
      log.traceFunc({"Partial match. Continuing"})
    } else if (groupMatch && !attemptingBacktrackMatch) {
      return attemptBacktrackMatch(context)
    } else {
      log.traceFunc({"Did not match. Disqualified"})
      disqualified = true
    }
  }

  attemptBacktrackMatch(ParseContext context) -> NodeGroupTokenMatch => null {
    let tokensToMatch = tokens.skip(groupMatch.tokens.count)
    resetCurrentParsers(context)
    currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    addedCurrentMatch = false
    log.traceFunc({"|
      Attempting backtrack match:
        old tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        new tokens: [#{groupMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        childMatches:
          #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
      |"})
    tokens = groupMatch.tokens.copy()
    if (tokensToMatch.isNotEmpty) {
      attemptingBacktrackMatch = true
      let values = tokensToMatch.map({
        return doMatch(_, context)
      })
      attemptingBacktrackMatch = false

      if (let backtrackMatch = values.lastWhere({ _ != null })) {
        if (values.last == null && partial) {
          log.traceFunc({"Successful backtrack match. Matcher is partial. Returning null"})
          return null
        }

        for (var Int i = values.count - 1; i >= 0; i--) {
          if (values[i] == null) {
            tokens.removeLast()
          }
        }

        log.traceFunc({"|
          Got successful backtrack match:
            matched tokens: [#{backtrackMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
          |"})

        return backtrackMatch
      } else {
        log.traceFunc({"|
          Failed backtrack match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
          |"})
        return null
      }
    } else {
      log.traceFunc({"No more tokens to match. Disqualified"})
      disqualified = true
    }
  }

  resetCurrentParsers(ParseContext context) {
    currentParsers = pattern.parsers
    currentParsers.forEach({ _.context = context })
  }

  override public reset() {
    if (!dirty) return

    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.reset() })
    childMatches = NodeTokenMatch[]
    groupMatch = null
    currentParsers = pattern.parsers
    currentMatcher = null
    addedCurrentMatch = false
    attemptingBacktrackMatch = false
  }
}