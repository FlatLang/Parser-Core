package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeGroupTokenMatcher.class)

  NodeGroupTokenPattern pattern

  var TokenMatch[] childMatches = TokenMatch[]
  var NodeGroupTokenMatch groupMatch
  var ParserBase[] currentParsers
  var NodeTokenMatcher currentMatcher
  var Bool addedCurrentMatch = false
  var Bool attemptingBacktrackMatch = false

  override public match(Token token, ParseContext context = null) -> NodeGroupTokenMatch {
    if (!currentParsers) {
      currentParsers = pattern.parsers
      currentParsers.forEach({ _.context = context })
    }
    if (!currentMatcher) {
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    }

    return tokenMatches.add(doMatch(token, context))
  }

  doMatch(Token token, ParseContext context) -> NodeGroupTokenMatch => null {
    if (disqualified) return null

    tokens.add(token)

    log.traceFunc({"|
      Matching token '#{green(token.value)}' #{magenta(token.location?.lineNumber.toString())}:#{magenta(token.location?.column.toString())}:
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
      |"})

    if (let match = currentMatcher.match(token, context)) {
      if (match.childMatches.isEmpty) {
        log.traceFunc({"Partial match for current matcher"})
        return null
      }
      log.traceFunc({"Successful match with current matcher. Parser: #{match.parser.class.name}"})
      let wasDisqualified = currentMatcher.disqualified
      if (currentMatcher.disqualified) {
        log.traceFunc({"Current matcher is disqualified. Returning match and switching to new current matcher"})
        currentParsers = pattern.parsers
        currentParsers.forEach({ _.context = context })
        currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
        complete = true
      } else {
        log.traceFunc({"Current matcher is partial. Returning match and continuing"})
      }

      valid = true

      if (addedCurrentMatch) {
        log.traceFunc({"Replacing last match"})
        childMatches.replaceLast(match)
      } else {
        log.traceFunc({"Adding last match"})
        childMatches.add(match)
      }

      addedCurrentMatch = true

      if (wasDisqualified) {
        addedCurrentMatch = false
      }

      log.traceFunc({"|
        Returning group match:
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
          childMatches:
            #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ") + "]").join("\n    ")}
        |"})

      if (groupMatch) {
        return groupMatch = groupMatch.copy(
          tokens: pattern.includeTokens ? tokens.copy() : Token[],
          childMatches: childMatches.copy()
        )
      } else {
        return groupMatch = NodeGroupTokenMatch(
          tokens: pattern.includeTokens ? tokens.copy() : Token[],
          label: pattern.label,
          childMatches: childMatches.copy()
        )
      }
    } else if (currentMatcher.partial) {
      log.traceFunc({"Partial match. Continuing"})
    } else if (groupMatch && !attemptingBacktrackMatch) {
      let tokensToMatch = tokens.skip(groupMatch.tokens.count)
      tokens = groupMatch.tokens.copy()
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
      addedCurrentMatch = false
      if (tokensToMatch.isNotEmpty) {
        log.traceFunc({"|
          Attempting backtrack match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
            childMatches.last.tokens: [#{childMatches.last.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
          |"})

        attemptingBacktrackMatch = true
        let values = tokensToMatch.map({
          return doMatch(_, context)
        })
        attemptingBacktrackMatch = false

        return values.lastWhere({ _ != null })
      } else {
        log.traceFunc({"No more tokens to match. Disqualified"})
        disqualified = true
      }
    } else {
      log.traceFunc({"Did not match. Disqualified"})
      disqualified = true
    }
  }

  override public reset() {
    if (!dirty) return

    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.reset() })
    childMatches = NodeTokenMatch[]
    groupMatch = null
    currentParsers = pattern.parsers
    currentMatcher = null
    addedCurrentMatch = false
    attemptingBacktrackMatch = false
  }
}