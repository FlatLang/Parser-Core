package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeGroupTokenMatcher.class)

  NodeGroupTokenPattern pattern

  var TokenMatch[] childMatches = TokenMatch[]
  var NodeGroupTokenMatch groupMatch
  var ParserBase[] currentParsers
  var NodeTokenMatcher currentMatcher
  var Bool addedCurrentMatch = false
  var Bool attemptingBacktrackMatch = false

  var TokenMatch[] nonGreedyChildMatches
  var NodeGroupTokenMatch nonGreedyGroupMatch

  override public match(Token token, ParseContext context = null) -> NodeGroupTokenMatch {
    if (!currentParsers) {
      resetCurrentParsers(context)
    }
    if (!currentMatcher) {
      currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    }

    return tokenMatches.add(doMatch(token, context))
  }

  doMatch(Token token, ParseContext context) -> NodeGroupTokenMatch => null {
    if (disqualified) return null

    tokens.add(token)

    log.traceFunc({"|
      Matching token '#{green(token.value)}' #{magenta(token.location?.lineNumber.toString())}:#{magenta(token.location?.column.toString())}:
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
      |"})

    if (let match = currentMatcher.match(token, context)) {
      if (match.childMatches.isEmpty) {
        log.traceFunc({"Partial match for current matcher"})
        return null
      }
      log.traceFunc({"|
        Successful match with current matcher:
          parser: #{green(match.parser.class.name)}
          pattern: #{magenta(match.parser.pattern.toPatternString())}
        |"})

      if (!match.parser.pattern.greedy) {
        log.traceFunc({"Current matcher is not greedy"})
        if (nonGreedyGroupMatch) {
          // should this be a stack?
          childMatches = nonGreedyChildMatches
          groupMatch = nonGreedyGroupMatch
          log.traceFunc({"Replacing last match"})
          nonGreedyChildMatches = childMatches.copy():replaceLast(match)
        } else {
          if (addedCurrentMatch) {
            log.traceFunc({"Replacing last match"})
            nonGreedyChildMatches = childMatches.copy():replaceLast(match)
          } else {
            log.traceFunc({"Adding last match"})
            nonGreedyChildMatches = childMatches.copy():add(match)
          }
        }

        nonGreedyGroupMatch = addNodeMatchToGroupMatch(match, nonGreedyChildMatches)

        log.traceFunc({"|
          Returning groupMatch immediately for partial match
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            nonGreedyGroupMatch.tokens: [#{nonGreedyGroupMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            nonGreedyChildMatches:
              #{nonGreedyChildMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          |"})

        return nonGreedyGroupMatch
      } else {
        resetNonGreedy()
      }

      let wasDisqualified = currentMatcher.disqualified
      if (wasDisqualified) {
        log.traceFunc({"Current matcher is disqualified. Returning match and switching to new current matcher"})
        resetCurrentParsers(context)
        currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
        complete = true
      } else {
        log.traceFunc({"Current matcher is partial. Returning match and continuing"})
      }

      valid = true

      if (addedCurrentMatch) {
        log.traceFunc({"Replacing last match"})
        childMatches.replaceLast(match)
      } else {
        log.traceFunc({"Adding last match"})
        childMatches.add(match)
      }

      if (wasDisqualified) {
        addedCurrentMatch = false
      } else {
        addedCurrentMatch = true
      }

      groupMatch = addNodeMatchToGroupMatch(match, childMatches.copy())

      if (groupMatch.tokens.count == tokens.count) {
        log.traceFunc({"|
          Returning group match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          |"})

        return groupMatch
      }

      if (let backtrack = attemptBacktrackMatch(context)) {
        return backtrack
      }

      if (!partial) {
        log.traceFunc({"|
          Backtrack was not partial. Returning group match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          |"})

        return groupMatch
      }
    } else if (currentMatcher.partial) {
      log.traceFunc({"Partial match. Continuing"})
    } else if (groupMatch && !attemptingBacktrackMatch) {
      let wasDisqualified = disqualified
      if (let nonGreedy = attemptNonGreedyMatch(context)) {
        return nonGreedy
      } else if (currentMatcher.partial) {
        log.traceFunc({"Partial non-greedy match. (not attempting another backtrack). Continuing"})
        return null
      } else {
        disqualified = wasDisqualified
      }

      return attemptBacktrackMatch(context)
    } else if (nonGreedyGroupMatch) {
      return attemptNonGreedyMatch(context)
    } else {
      log.traceFunc({"Did not match. Disqualified"})
      disqualified = true
    }
  }

  resetNonGreedy() {
    nonGreedyChildMatches = null
    nonGreedyGroupMatch = null
  }

  attemptNonGreedyMatch(ParseContext context) -> NodeGroupTokenMatch => null {
    if (!nonGreedyGroupMatch) return null

    log.traceFunc({"Attempting non-greedy match"})
    let tmpChildMatches = childMatches
    let tmpGroupMatch = groupMatch
    childMatches = nonGreedyChildMatches
    groupMatch = nonGreedyGroupMatch
    resetNonGreedy()

    if (let backtrack = attemptBacktrackMatch(context)) {
      return backtrack
    } else if (currentMatcher.partial) {
      log.traceFunc({"Partial non-greedy match. Continuing"})
      return null
    }

    childMatches = tmpChildMatches
    groupMatch = tmpGroupMatch
  }

  addNodeMatchToGroupMatch(NodeTokenMatch match, TokenMatch[] childMatches) -> NodeGroupTokenMatch {
    if (groupMatch) {
      log.traceFunc({"|
        Adding to current groupMatch
          current groupMatch.tokens: [#{groupMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          match.tokens: [#{match.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        |"})
      return groupMatch.copy(
        tokens: pattern.includeTokens ? childMatches.flatMap({ _.tokens }) : Token[],
        childMatches: childMatches
      )
    } else {
      log.traceFunc({"|
        Creating new groupMatch from tokens:
          match.tokens: [#{match.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        |"})
      return NodeGroupTokenMatch(
        tokens: pattern.includeTokens ? match.tokens.copy() : Token[],
        label: pattern.label,
        childMatches: childMatches
      )
    }
  }

  attemptBacktrackMatch(ParseContext context) -> NodeGroupTokenMatch => null {
    let tokensToMatch = tokens.skip(groupMatch.tokens.count)
    resetCurrentParsers(context)
    resetNonGreedy()
    currentMatcher = NodeTokenPattern(currentParsers).getMatcher()
    addedCurrentMatch = false
    log.traceFunc({"|
      Attempting backtrack match:
        old tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        new tokens: [#{groupMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        childMatches:
          #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
      |"})
    tokens = groupMatch.tokens.copy()
    if (tokensToMatch.isNotEmpty) {
      attemptingBacktrackMatch = true
      let values = tokensToMatch.map({
        return doMatch(_, context)
      })
      attemptingBacktrackMatch = false

      if (let backtrackMatch = values.lastWhere({ _ != null })) {
        if (values.last == null && partial) {
          log.traceFunc({"Successful backtrack match. Matcher is partial. Returning null"})
          return null
        }

        for (var Int i = values.count - 1; i >= 0; i--) {
          if (values[i] == null) {
            tokens.removeLast()
          }
        }

        log.traceFunc({"|
          Got successful backtrack match:
            matched tokens: [#{backtrackMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
          |"})

        return backtrackMatch
      } else {
        log.traceFunc({"|
          Failed backtrack match:
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
          |"})
        return null
      }
    } else {
      log.traceFunc({"No more tokens to match. Disqualified"})
      disqualified = true
    }
  }

  resetCurrentParsers(ParseContext context) {
    currentParsers = pattern.parsers
    currentParsers.forEach({ _.context = context })
  }

  override public reset() {
    if (!dirty) return

    log.traceFunc({"Resetting matcher"})
    super.reset()

    pattern.parsers.forEach({ _.reset() })
    childMatches = NodeTokenMatch[]
    groupMatch = null
    currentParsers = pattern.parsers
    currentMatcher = null
    addedCurrentMatch = false
    attemptingBacktrackMatch = false
  }
}