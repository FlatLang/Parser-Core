package flat/parser/matchers

import flat/parser
import flat/ast
import flat/annotations
import flat/parser/flat
import flat/compiler/models
import flat/datastruct/HashMap
import flat/io/File

testable class {
    test `can match one import`() {
        let pattern = NodeGroupTokenPattern([ImportParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "import", type: Token.Type.IDENTIFIER),
            Token(value: "test", type: Token.Type.IDENTIFIER)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "import", type: Token.Type.IDENTIFIER),
                    Token(value: "test", type: Token.Type.IDENTIFIER)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "import", type: Token.Type.IDENTIFIER),
                            Token(value: "test", type: Token.Type.IDENTIFIER)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "import", type: Token.Type.IDENTIFIER),
                                    Token(value: "test", type: Token.Type.IDENTIFIER)
                                ],
                                parser: ImportParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match two imports`() {
        let pattern = NodeGroupTokenPattern([ImportParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "import", type: Token.Type.IDENTIFIER),
            Token(value: "test", type: Token.Type.IDENTIFIER),
            Token(value: "import", type: Token.Type.IDENTIFIER),
            Token(value: "test2", type: Token.Type.IDENTIFIER)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "import", type: Token.Type.IDENTIFIER),
                    Token(value: "test", type: Token.Type.IDENTIFIER),
                    Token(value: "import", type: Token.Type.IDENTIFIER),
                    Token(value: "test2", type: Token.Type.IDENTIFIER)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "import", type: Token.Type.IDENTIFIER),
                            Token(value: "test", type: Token.Type.IDENTIFIER)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "import", type: Token.Type.IDENTIFIER),
                                    Token(value: "test", type: Token.Type.IDENTIFIER)
                                ],
                                parser: ImportParser()
                            )
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "import", type: Token.Type.IDENTIFIER),
                            Token(value: "test2", type: Token.Type.IDENTIFIER)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "import", type: Token.Type.IDENTIFIER),
                                    Token(value: "test2", type: Token.Type.IDENTIFIER)
                                ],
                                parser: ImportParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match one function call`() {
        let pattern = NodeGroupTokenPattern([FunctionCallParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "test", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: ")", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "test", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: ")", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "test", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: ")", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "test", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: ")", type: Token.Type.SYMBOL)
                                ],
                                parser: FunctionCallParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match two function calls`() {
        let pattern = NodeGroupTokenPattern([FunctionCallParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "test", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "test2", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: ")", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "test", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "test2", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: ")", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "test", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: ")", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "test", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: ")", type: Token.Type.SYMBOL)
                                ],
                                parser: FunctionCallParser()
                            )
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "test2", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: ")", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "test2", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: ")", type: Token.Type.SYMBOL)
                                ],
                                parser: FunctionCallParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match one if statement`() {
        let pattern = NodeGroupTokenPattern([IfParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "}", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "}", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "}", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "{", type: Token.Type.SYMBOL),
                                    Token(value: "}", type: Token.Type.SYMBOL)
                                ],
                                parser: IfParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match two if statements`() {
        let pattern = NodeGroupTokenPattern([IfParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "}", type: Token.Type.SYMBOL),
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "}", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "}", type: Token.Type.SYMBOL),
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "}", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "}", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "{", type: Token.Type.SYMBOL),
                                    Token(value: "}", type: Token.Type.SYMBOL)
                                ],
                                parser: IfParser()
                            )
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "}", type: Token.Type.SYMBOL)
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "y", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "{", type: Token.Type.SYMBOL),
                                    Token(value: "}", type: Token.Type.SYMBOL)
                                ],
                                parser: IfParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match one if statement with one tested if statement`() {
        let pattern = NodeGroupTokenPattern([IfParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "}", type: Token.Type.SYMBOL),
            Token(value: "}", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "}", type: Token.Type.SYMBOL),
                    Token(value: "}", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "}", type: Token.Type.SYMBOL),
                            Token(value: "}", type: Token.Type.SYMBOL),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "{", type: Token.Type.SYMBOL),
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "y", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "{", type: Token.Type.SYMBOL),
                                    Token(value: "}", type: Token.Type.SYMBOL),
                                    Token(value: "}", type: Token.Type.SYMBOL),
                                ],
                                parser: IfParser()
                            )
                        ]
                    )
                ]
            )
        )
    }

    test `can match inside a group token pattern`() {
        let pattern = GroupTokenPattern([
            SingleTokenPattern(type: Token.Type.SYMBOL, value: "{"),
            NodeGroupTokenPattern(LocalScopeParser().valueParsers, optional: true),
            SingleTokenPattern(type: Token.Type.SYMBOL, value: "}")
        ])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "}", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            GroupTokenMatch(
                tokens: [
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "}", type: Token.Type.SYMBOL)
                ],
                tokenMatches: [
                    SingleTokenMatch(
                        tokens: [Token(value: "{", type: Token.Type.SYMBOL)]
                    ),
                    NodeGroupTokenMatch(
                        tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                        childMatches: [
                            NodeTokenMatch(
                                tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                                childMatches: [
                                    NodeTokenMatchChild(
                                        tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                                        parser: IdentifierParser()
                                    )
                                ]
                            )
                        ]
                    ),
                    SingleTokenMatch(
                        tokens: [Token(value: "}", type: Token.Type.SYMBOL)]
                    )
                ]
            )
        )
    }

    test `can match inside a node token pattern`() {
        let pattern = NodeTokenPattern([LambdaParser()])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "{", type: Token.Type.SYMBOL),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "}", type: Token.Type.SYMBOL)
        ], ParseContext()).last

        expect(result).toBe(
            NodeTokenMatch(
                tokens: [
                    Token(value: "{", type: Token.Type.SYMBOL),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "}", type: Token.Type.SYMBOL)
                ],
                childMatches: [
                    NodeTokenMatchChild(
                        tokens: [
                            Token(value: "{", type: Token.Type.SYMBOL),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: "}", type: Token.Type.SYMBOL)
                        ],
                        parser: LambdaParser()
                    )
                ]
            )
        )
    }

    test `can match identifier and then function call`() {
        let pattern = NodeGroupTokenPattern([
            LocalDeclarationParser(),
            IdentifierParser(),
            FunctionCallParser(),
        ])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: ")", type: Token.Type.SYMBOL),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: ")", type: Token.Type.SYMBOL),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            )
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: ")", type: Token.Type.SYMBOL),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "y", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                ],
                                parser: FunctionCallParser()
                            )
                        ]
                    ),
                ]
            )
        )
    }

    test `can match local declaration with explicit type and then assignment`() {
        let pattern = NodeGroupTokenPattern([
            LocalDeclarationParser(),
            IdentifierParser(),
            AssignmentParser(),
        ])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "String", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "=", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "String", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "=", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "String", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: "=", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "String", type: Token.Type.IDENTIFIER),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                ],
                                parser: LocalDeclarationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "=", type: Token.Type.SYMBOL)],
                                parser: AssignmentParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "y", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }

    test `can match local declaration with implicit type and then assignment`() {
        let pattern = NodeGroupTokenPattern(LocalScopeParser().valueParsers)

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "let", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "=", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "let", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "=", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "let", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: "=", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "let", type: Token.Type.IDENTIFIER)],
                                parser: AnnotationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                                parser: LocalDeclarationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "=", type: Token.Type.SYMBOL)],
                                parser: AssignmentParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "y", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }

    test `can match local declaration with explicit type and var modifier then separate assignment statement`() {
        let pattern = NodeGroupTokenPattern(LocalScopeParser().valueParsers)

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "var", type: Token.Type.IDENTIFIER),
            Token(value: "String", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "z", type: Token.Type.IDENTIFIER),
            Token(value: "=", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "var", type: Token.Type.IDENTIFIER),
                    Token(value: "String", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "z", type: Token.Type.IDENTIFIER),
                    Token(value: "=", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "var", type: Token.Type.IDENTIFIER),
                            Token(value: "String", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "var", type: Token.Type.IDENTIFIER)],
                                parser: AnnotationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "String", type: Token.Type.IDENTIFIER),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                ],
                                parser: LocalDeclarationParser()
                            ),
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "z", type: Token.Type.IDENTIFIER),
                            Token(value: "=", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "z", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "=", type: Token.Type.SYMBOL)],
                                parser: AssignmentParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "y", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }

    test `can match local declaration with explicit type and var modifier then separate if statement`() {
        let pattern = NodeGroupTokenPattern(LocalScopeParser().valueParsers)

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "var", type: Token.Type.IDENTIFIER),
            Token(value: "String", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "if", type: Token.Type.IDENTIFIER),
            Token(value: "(", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: ")", type: Token.Type.SYMBOL),
            Token(value: "z", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "var", type: Token.Type.IDENTIFIER),
                    Token(value: "String", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "if", type: Token.Type.IDENTIFIER),
                    Token(value: "(", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: ")", type: Token.Type.SYMBOL),
                    Token(value: "z", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "var", type: Token.Type.IDENTIFIER),
                            Token(value: "String", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "var", type: Token.Type.IDENTIFIER)],
                                parser: AnnotationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "String", type: Token.Type.IDENTIFIER),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                ],
                                parser: LocalDeclarationParser()
                            ),
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "if", type: Token.Type.IDENTIFIER),
                            Token(value: "(", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                            Token(value: ")", type: Token.Type.SYMBOL),
                            Token(value: "z", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "if", type: Token.Type.IDENTIFIER),
                                    Token(value: "(", type: Token.Type.SYMBOL),
                                    Token(value: "y", type: Token.Type.IDENTIFIER),
                                    Token(value: ")", type: Token.Type.SYMBOL),
                                    Token(value: "z", type: Token.Type.IDENTIFIER),
                                ],
                                parser: IfParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }

    test `can match local declaration with implicit type then separate identifier`() {
        let pattern = NodeGroupTokenPattern(LocalScopeParser().valueParsers)

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "let", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "=", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: "z", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "let", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "=", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: "z", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "let", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: "=", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "let", type: Token.Type.IDENTIFIER)],
                                parser: AnnotationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "x", type: Token.Type.IDENTIFIER)],
                                parser: LocalDeclarationParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "=", type: Token.Type.SYMBOL)],
                                parser: AssignmentParser()
                            ),
                            NodeTokenMatchChild(
                                tokens: [Token(value: "y", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "z", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [Token(value: "z", type: Token.Type.IDENTIFIER)],
                                parser: IdentifierParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }

    test `can match package and then import`() {
        let pattern = NodeGroupTokenPattern([
            AnnotationParser(),
            ImportParser(),
            PackageParser(),
            ClassParser()
        ])

        let matcher = pattern.getMatcher()
        let result = matcher.matchAll([
            Token(value: "package", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
            Token(value: "/", type: Token.Type.SYMBOL),
            Token(value: "y", type: Token.Type.IDENTIFIER),
            Token(value: "import", type: Token.Type.IDENTIFIER),
            Token(value: "x", type: Token.Type.IDENTIFIER),
        ], ParseContext()).last

        expect(result).toBe(
            NodeGroupTokenMatch(
                tokens: [
                    Token(value: "package", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                    Token(value: "/", type: Token.Type.SYMBOL),
                    Token(value: "y", type: Token.Type.IDENTIFIER),
                    Token(value: "import", type: Token.Type.IDENTIFIER),
                    Token(value: "x", type: Token.Type.IDENTIFIER),
                ],
                childMatches: [
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "package", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                            Token(value: "/", type: Token.Type.SYMBOL),
                            Token(value: "y", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "package", type: Token.Type.IDENTIFIER),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                    Token(value: "/", type: Token.Type.SYMBOL),
                                    Token(value: "y", type: Token.Type.IDENTIFIER),
                                ],
                                parser: PackageParser()
                            ),
                        ]
                    ),
                    NodeTokenMatch(
                        tokens: [
                            Token(value: "import", type: Token.Type.IDENTIFIER),
                            Token(value: "x", type: Token.Type.IDENTIFIER),
                        ],
                        childMatches: [
                            NodeTokenMatchChild(
                                tokens: [
                                    Token(value: "import", type: Token.Type.IDENTIFIER),
                                    Token(value: "x", type: Token.Type.IDENTIFIER),
                                ],
                                parser: ImportParser()
                            ),
                        ]
                    ),
                ]
            )
        )
    }
}
