package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

data class extends TokenMatcher {
  static Logger log = Logger(PreconditionTokenMatcher.class)

  PreconditionTokenPattern pattern

  override public checkMatch(Token token, ParseContext context) -> PreconditionTokenMatch => null {
    if (disqualified) return null
    if (!context) {
      disqualified = true
      log.traceFunc({"No context. Disqualified"})
      return null
    }

    disqualified = true

    if (pattern.annotations) {
      log.traceFunc({"Matcher has annotation checks for: [#{pattern.annotations.map(a => a.name).join(", ")}]"})
      if (pattern.annotations.any(requiredAnnotation => context.annotations.none({ _.class == requiredAnnotation }))) {
        log.traceFunc({"Context annotations have none of the required annotations"})
        return null
      } else {
        log.traceFunc({"Matched all of the required annotations"})
      }
    } else {
      log.traceFunc({"Matcher has no annotation checks"})
    }

    if (pattern.baseParentTypes) {
      if (let parser = context.currentBaseParser) {
        let baseParent = parser.class.name.trimEnd(count: 6)
        log.traceFunc({"Matcher has baseParentType checks for: [#{pattern.baseParentTypes.map(a => a.name.trimEnd(count: 4)).join(", ")}] against #{baseParent}"})
        if (pattern.baseParentTypes.none(requiredType => baseParent == requiredType.name.trimEnd(count: 4))) {
          log.traceFunc({"Context parent is not one of the required baseParentTypes"})
          return null
        } else {
          log.traceFunc({"Matched some of the required baseParentTypes"})
        }
      } else {
        disqualified = true
        log.traceFunc({"Context parent is not set. Disqualified"})
        return null
      }
    } else {
      log.traceFunc({"Matcher has no baseParentType checks"})
    }

    if (pattern.parentTypes) {
      if (let parser = context.currentParentParser) {
        let parentName = parser.class.name.trimEnd(count: 6)
        log.traceFunc({"Matcher has parentType checks for: [#{pattern.parentTypes.map(a => a.name.trimEnd(count: 4)).join(", ")}] against #{parentName}"})
        if (pattern.parentTypes.none(requiredType => parentName == requiredType.name.trimEnd(count: 4))) {
          log.traceFunc({"Context parent is not one of the required parentTypes"})
          return null
        } else {
          log.traceFunc({"Matched some of the required parentTypes"})
        }
      } else {
        disqualified = true
        log.traceFunc({"Context parent is not set. Disqualified"})
        return null
      }
    } else {
      log.traceFunc({"Matcher has no parentType checks"})
    }

    log.traceFunc({"Precondition passed successfully"})
    complete = true
    valid = true

    return PreconditionTokenMatch(
      tokens: pattern.includeTokens ? tokens.copy() : Token[]
    )
  }
}