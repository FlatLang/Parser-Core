package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/datastruct/list/Queue
import flat/datastruct/list/Stack
import flat/datastruct/list/ArrayIterator
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(GroupTokenMatcher.class)

  GroupTokenPattern pattern

  lazy ArrayIterator<TokenMatcher> iterator => pattern.patterns.map({ _.getMatcher() }).iterator
  lazy Stack<TokenMatcher> nonGreedyMatchers => Stack()

  lazy TokenMatch[] successfulMatches => TokenMatch[]

  var TokenMatcher lastMatcher
  var TokenMatcher matcher
  var Bool nonGreedyChecked = false
  var Token[] successfulMatchedTokens = Token[]

  hasNextMatcher() -> Bool {
    return iterator.hasNext && nonGreedyMatchers.count + iterator.position < pattern.patterns.count
  }

  nextMatcher() {
    nonGreedyChecked = false

    while (nonGreedyMatchers.isNotEmpty) {
      log.traceFunc({"Popping nonGreedyMatcher"})
      nonGreedyMatchers.pop()

      matcher = iterator.stepNext
    }

    matcher = iterator.stepNext
  }

  repeatMatcher() {
    log.traceFunc({"Repeating matcher: " + magenta(matcher.pattern.toPatternString())})
    matcher = matcher.pattern.getMatcher()
  }

  addSuccessfulMatch(TokenMatch tokenMatch) {
    if (!Object.referenceEquals(matcher, lastMatcher)) {
      log.traceFunc({"Adding tokens to successfulMatchedTokens: [#{tokenMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]"})
      successfulMatches.add(tokenMatch)
      successfulMatchedTokens.addAll(tokenMatch.tokens)
    } else {
      successfulMatches[successfulMatches.count - 1] = tokenMatch
      successfulMatchedTokens = successfulMatches.flatMap({ _.tokens })
      log.traceFunc({"Replaced successfulMatchedTokens"})
    }
    lastMatcher = matcher
  }

  override public match(Token token, ParseContext context = null) => tokenMatches.add(doMatch(token, context))

  doMatch(Token token, ParseContext context) -> TokenMatch => null {
    if (disqualified) return null
    if (tokens.isEmpty) {
      if (hasNextMatcher()) {
        nextMatcher()
      } else {
        log.traceFunc({"No more matchers. Disqualified"})
        disqualified = true
        return null
      }
    }
    if (!matcher) {
      log.traceFunc({"No matcher. Disqualified"})
      disqualified = true
      return null
    }

    tokens.add(token)

    return this.match(context)
  }

  match(ParseContext context) -> TokenMatch => null {
    let token = tokens.last

    log.traceFunc({"|
      Matching tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        matcher: #{magenta(matcher.pattern.toPatternString())}
        matcher.valid: #{matcher.valid}
        matcher.complete: #{matcher.complete}
        matcher.pattern.greedy: #{matcher.pattern.greedy}
        nonGreedyChecked: #{nonGreedyChecked}
        pattern: #{magenta(pattern.toPatternString())}
      |"})

    // TODO: Allow matcher.valid here too
    if ((matcher.pattern.optional || matcher.valid && matcher.complete) && !matcher.pattern.greedy && !nonGreedyChecked) {
      if (hasNextMatcher()) {
        log.traceFunc({"Checking next matcher because current matcher is non-greedy optional"})
        nonGreedyMatchers.push(matcher)
        matcher = iterator.next.copy()
      } else {
        log.traceFunc({"No other matchers to match. Skipping greedy check"})
      }
    }

    if (let tokenMatch = matcher.match(token, context)) {
      nonGreedyChecked = false
      return handleSuccessfulMatch(tokenMatch, context)
    } else if (matcher.partial) {
      log.traceFunc({"Returning null for partial match. matcher: " + magenta(matcher.pattern.toPatternString())})
      return null
    } else if (matcher.valid && matcher.pattern.repeat) {
      repeatMatcher()
      return this.match(context)
    } else if (nonGreedyMatchers.isNotEmpty) {
      if (matcher.valid) {
        log.traceFunc({"Non-greedy matcher check is valid but partial. Returning last match"})
        return checkRemainingMatch(context)
      }

      log.traceFunc({"|
        Did not match the non-greedy matcher check. Reverting back to before non-greedy check
          matcher: #{magenta(matcher.pattern.toPatternString())}
          pattern: #{magenta(pattern.toPatternString())}
          nonGreedyMatchers:
            #{nonGreedyMatchers.toArray().map(m => magenta(m.pattern.toPatternString())).join("\n    ")}
        |"})

      if (matcher.pattern.optional && (let next = iterator.allNext.skip(nonGreedyMatchers.count).first)) {
        nonGreedyMatchers.push(matcher)
        matcher = next.copy()
        log.traceFunc({"Matcher was optional and has a next matcher. Skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
      } else {
        while (nonGreedyMatchers.count > 1) {
          nonGreedyMatchers.pop()
        }

        matcher = nonGreedyMatchers.pop()
        nonGreedyChecked = true
        log.traceFunc({"Popped greedy matchers"})
      }

      return continuationMatch(context)
    } else if (hasNextMatcher()) {
      if (matcher.complete && matcher.valid) {
        nextMatcher()
        return continuationMatch(context)
      } else if (matcher.pattern.optional) {
        nextMatcher()
        log.traceFunc({"|
          Did not match the optional matcher. Skipped to next matcher: #{magenta(matcher.pattern.toPatternString())}
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            pattern: #{magenta(pattern.toPatternString())}
          |"})

        return continuationMatch(context)
      } else if (matcher.tokenMatches.getLast(1) != null) { // maybe need to check that the most recent match wasnt required
        nextMatcher()
        log.traceFunc({"Did not match, but had most recently successfully matched. Skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
        return this.match(context)
      }
    }

    complete = complete || iterator.allNextInclusive.all({ _.pattern.optional })
    disqualified = true
    log.traceFunc({"|
      Did not match the matcher
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
        matcher: #{magenta(matcher.pattern.toPatternString())}
        pattern: #{magenta(pattern.toPatternString())}
      |"})
  }

  continuationMatch(ParseContext context) -> GroupTokenMatch {
    let tokensToMatch = tokens.skip(successfulMatchedTokens.count)
    tokens = successfulMatchedTokens.copy()
    log.traceFunc({"|
      Running continuation match:
        successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        matcher: #{magenta(matcher.pattern.toPatternString())}
        pattern: #{magenta(pattern.toPatternString())}
      |"})

    let continuationMatches = tokensToMatch.map({
      if (disqualified) {
        return null
      }
      tokens.add(_)
      return this.match(context)
    })

    return continuationMatches.lastWhere({ _ != null })
  }

  handleSuccessfulMatch(TokenMatch tokenMatch, ParseContext context) -> GroupTokenMatch {
    log.traceFunc({"|
      Matched tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        matched tokens: [#{tokenMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        matcher: #{magenta(matcher.pattern.toPatternString())}
        pattern: #{magenta(pattern.toPatternString())}
      |"})
    addSuccessfulMatch(tokenMatch)

    if (successfulMatchedTokens.count < tokens.count) {
      return checkRemainingMatch(context)
    } else {
      log.traceFunc({"No partial match remaining tokens"})
    }

    if (matcher.disqualified) {
      if (matcher.pattern.repeat) {
        if (matcher.complete) {
          log.traceFunc({"Matcher is complete and disqualified"})
          if (matcher.pattern.greedy) {
            repeatMatcher()
            if (iterator.allNext.any({ !_.pattern.optional })) {
              log.traceFunc({"|
                Contains future required matchers. Returning null
                  next matchers:
                    #{iterator.allNextInclusive.map(m => (m.pattern.optional ? "optional: " : "required: ") + magenta(m.pattern.toPatternString())).join("\n    ")}
                  pattern: #{magenta(pattern.toPatternString())}
                |"})
              return null
            } else {
              log.traceFunc({"The rest of the matchers are optional. Returning match"})
              valid = true
            }
          } else {
            if (hasNextMatcher()) {
              nextMatcher()

              if (iterator.allNextInclusive.all({ _.pattern.optional })) {
                log.traceFunc({"This matcher is not greedy and there are other matchers. Returning match and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
              } else {
                log.traceFunc({"This matcher is not greedy and there are other required. Returning null for partial match and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
                return null
              }
            } else {
              log.traceFunc({"This matcher is not greedy and there are no other matchers. Completing and returning match"})
              complete = true
              repeatMatcher()
            }
          }
        } else {
          log.traceFunc({"Matcher is not complete, but is disqualified"})
          if (hasNextMatcher()) {
            nextMatcher()
            if (iterator.allNextInclusive.all({ _.pattern.optional })) {
              log.traceFunc({"The rest of the matchers are optional. Returning match and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
              valid = true
            } else {
              log.traceFunc({"There are still some required matchers. Returning null and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
              return null
            }
          } else {
            log.traceFunc({"There are no other matchers. Completing and returning match"})
            complete = true
            valid = true
          }
        }
      } else if (hasNextMatcher()) {
        if (matcher.disqualified) {
          nextMatcher()
          if (iterator.allNextInclusive.all({ _.pattern.optional })) {
            log.traceFunc({"The rest of the matchers are optional. Returning match and skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
            valid = true
          } else {
            log.traceFunc({"|
              There are still some required matchers. Returning null and skipped to next matcher: #{magenta(matcher.pattern.toPatternString())}
                next matchers:
                  #{iterator.allNextInclusive.map(m => (m.pattern.optional ? "optional: " : "required: ") + magenta(m.pattern.toPatternString())).join("\n    ")}
                pattern: #{magenta(pattern.toPatternString())}
              |"})
            return null
          }
        } else { // FIXME: handle non-greedy
          log.traceFunc({"Matcher is not disqualified, not iterating to next matcher"})
          if (iterator.allNext.any({ !_.pattern.optional })) {
            log.traceFunc({"|
              Contains future required matchers. Returning null
                next matchers:
                  #{iterator.allNextInclusive.map(m => (m.pattern.optional ? "optional: " : "required: ") + magenta(m.pattern.toPatternString())).join("\n    ")}
                pattern: #{magenta(pattern.toPatternString())}
              |"})
            return null
          } else {
            log.traceFunc({"The rest of the matchers are optional. Returning match"})
          }
        }
      } else {
        disqualified = matcher.disqualified
        valid = matcher.valid
        complete = matcher.complete
        log.traceFunc({"|
          No more matchers. Returning match.
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            matcher: #{magenta(matcher.pattern.toPatternString())}
            pattern: #{magenta(pattern.toPatternString())}
          |"})
      }
    } else if (matcher.valid) {
      log.traceFunc({"Matcher is valid, but not disqualified"})
      if (!hasNextMatcher()) {
        complete = matcher.complete
        valid = true
        log.traceFunc({"No other matchers. Returning match. complete: #{complete}"})
      } else if (iterator.allNext.all({ _.pattern.optional })) {
        log.traceFunc({"All remaining matchers are optional. Returning match"})
        valid = true
      } else {
        log.traceFunc({"|
          Contains future required matchers. Returning null
            next matchers:
              #{iterator.allNextInclusive.map(m => (m.pattern.optional ? "optional: " : "required: ") + magenta(m.pattern.toPatternString())).join("\n    ")}
            pattern: #{magenta(pattern.toPatternString())}
          |"})
        return null
      }
    } else {
      log.traceFunc({"Matcher is partial. Returning null"})
      return null
    }

    return GroupTokenMatch(
      tokens: pattern.includeTokens ? tokens.copy() : Token[],
      tokenMatches: successfulMatches.copy(),
      label: pattern.label
    )
  }

  checkRemainingMatch(ParseContext context) -> GroupTokenMatch => null {
    let tokensToMatch = tokens.skip(successfulMatchedTokens.count)
    log.traceFunc({"|
      Contains remaining tokens from partial match:
        tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        old tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        hasNext: #{hasNextMatcher()}
        repeat: #{matcher.pattern.repeat}
        complete: #{matcher.complete}
        matcher: #{magenta(matcher.pattern.toPatternString())}
        pattern: #{magenta(pattern.toPatternString())}
      |"})
    tokens = successfulMatchedTokens.copy()

    var Bool continueMatching = false
    complete = complete || !hasNextMatcher()

    if (matcher.pattern.repeat && matcher.complete) { // Should this be `matcher.disqualified`?
      repeatMatcher()
      continueMatching = true
    } else if (hasNextMatcher() && matcher.complete && matcher.disqualified) { // FIXME: handle non-greedy
      nextMatcher()
      log.traceFunc({"Skipped to next matcher: " + magenta(matcher.pattern.toPatternString())})
      continueMatching = true
    } else if (matcher.partial) {
      continueMatching = true
    }

    if (continueMatching) {
      log.traceFunc({"successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]"})
      log.traceFunc({"Iterating through tokens: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]"})
      let continuationMatches = tokensToMatch.map({
        if (disqualified) {
          return null
        }

        tokens.add(_)
        return this.match(context)
      })

      if (let continuationMatch = continuationMatches.lastWhere({ _ != null })) {
        log.traceFunc({"Returning successful continuation match"})
        return continuationMatch
      } else {
        log.traceFunc({"Continuation match was not successful"})

        if (matcher.disqualified) {
          disqualified = true
          if (matcher.complete) {
            log.traceFunc({"Continuation match was complete and disqualified. Disqualified. Returning successful match without the remaining tokens"})
          } else {
            log.traceFunc({"Continuation match was invalid and disqualified. Disqualified"})
            return null
          }
        } else if (matcher.partial) {
          log.traceFunc({"Continuation match is partial. Returning null"})
          return null
        }
      }
    } else {
      disqualified = true
    }

    log.traceFunc({"|
      Returning successful match without the remaining tokens.
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
        successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
      |"})

    return GroupTokenMatch(
      tokens: successfulMatchedTokens.copy(),
      tokenMatches: successfulMatches.copy(),
      label: pattern.label
    )
  }

  override public reset() {
    if (!dirty) return

    if (matcher == null) return
    log.traceFunc({"Resetting matcher"})
    super.reset()

    iterator.reset()
    iterator.allNextInclusive.forEach({ _.reset() })
    nonGreedyMatchers.clear()
    successfulMatches.clear()
    successfulMatchedTokens = Token[]
    lastMatcher = null
    matcher = null
    nonGreedyChecked = false
  }
}