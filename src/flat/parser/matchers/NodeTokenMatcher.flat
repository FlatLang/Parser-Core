package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeTokenMatcher.class)

  NodeTokenPattern pattern

  var ParseContext context
  var NodeTokenMatch lastMatch
  var TokenMatch targetMatch
  var TokenMatch lastTargetMatch
  var NodeTokenMatchChild[] childMatches = NodeTokenMatchChild[]
  var ParserBase[] currentParsers
  var Bool attemptingBacktrack = false
  var Bool addedCurrentMatch = false
  var Token[] successfulMatchedTokens = Token[]

  ParserBase lastParser => childMatches.last?.parser

  override public match(Token token, ParseContext context = null) -> NodeTokenMatch {
    if (!this.context) {
      this.context = context?.copy(
        annotations: Array(),
        currentBaseParser: pattern.baseParser ? context.parserStack.peek() : context.currentBaseParser
      )

      if (!this.context) {
        this.context = ParseContext()
      }
    }
    if (!currentParsers) {
      setCurrentParsers(pattern.parsers.forEach({ _.copy() }))
    }

    tokens.add(token)

    return tokenMatches.add(doMatch(token))
  }

  doMatch(Token token) -> NodeTokenMatch {
    if (disqualified) return null
    log.traceFunc({"|
      Matching token '#{green(token.value)}' #{token.type}
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        childMatches:
          #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        currentParsers complete/disqualified/partial:
          [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
        statementEndToken: #{pattern.statementEndToken?.value}
      |"})

    var ParserBase targetParser
    targetMatch = null
    let matchParsers = ParserBase[]
    let matches = TokenMatch[]

    for (parser in currentParsers) {
      if (parser.matcher.disqualified) continue
      log.traceFunc({"|
        Matching token '#{green(token.value)}' #{magenta(token.location?.lineNumber.toString())}:#{magenta(token.location?.column.toString())} against parser: #{green(parser.class.name)}
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          childMatches:
            #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        |"})
      if (let match = parser.match(token)) {
        log.traceFunc({"|
          Matched token '#{green(token.value)}'
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            match.tokens: [#{match.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          |"})
        matches.add(match)
        matchParsers.add(parser)
        if (!targetParser || parser.matcher.pattern.exact) {
          targetParser = parser
          targetMatch = match

          if (parser.matcher.pattern.exact) {
            break
          }
        }
      } else if (parser.matcher.partial) {
        log.traceFunc({"Partial match for token '#{green(token.value)}'"})
      } else {
        log.traceFunc({"Didn't match token '#{green(token.value)}'"})
      }
      log.traceFunc({"|
        Finished matching token '#{green(token.value)}' against parser: #{green(parser.class.name)}
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          valid: #{valid}
          complete: #{complete}
        |"})
    }

    log.traceFunc({"|
      Finished matching all current parsers:
        matches.count: #{matches.count}
        targetParser: #{targetParser.class.name}
        parsers: [#{currentParsers.filter(p => p != targetParser && p.matcher.partial).map(p => green(p.class.name)).join(", ", 50)}]
        valid: #{valid}
        complete: #{complete}
        childMatches:
          #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
      |"})

    if (allParsersDisqualified()) {
      log.traceFunc({"All parsers are disqualified"})
      if (let statementEnd = checkStatementEnd(token, targetParser, targetMatch)) {
        return statementEnd
      }
      if (childMatches.isNotEmpty) {
        if (attemptingBacktrack) {
          log.traceFunc({"Already attempting backtrack match. Disqualified"})
          disqualified = true
          return null
        }

        return attemptBacktrackMatch()
      }
    } else {
      valid = true
    }

    let remainingPartialMatches = currentParsers.any(p => p != targetParser && p.matcher.partial)

    if (matches.isNotEmpty) {
      complete = complete || targetParser.matcher.complete
      log.traceFunc({"|
        Contains matches for parser: #{green(targetParser.class.name)}
          #{matchParsers.map(m => magenta(m.pattern.toPatternString())).join("\n  ")}
          valid: #{valid}
          complete: #{complete}
          childMatches:
            #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        |"})

      if (addedCurrentMatch) {
        successfulMatchedTokens.addAll(targetMatch.tokens.skip(lastTargetMatch.tokens.count))
        log.traceFunc({"|
          Replacing last match
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            targetMatch.tokens: [#{targetMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            lastTargetMatch.tokens: [#{lastTargetMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          |"})
        childMatches.replaceLast(
          NodeTokenMatchChild(
            tokens: targetMatch.tokens,
            parser: targetParser
          )
        )
      } else {
        successfulMatchedTokens.addAll(targetMatch.tokens)
        log.traceFunc({"|
          Adding last match
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            targetMatch.tokens: [#{targetMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          |"})
        childMatches.add(
          NodeTokenMatchChild(
            tokens: targetMatch.tokens,
            parser: targetParser
          )
        )
      }

      lastTargetMatch = targetMatch
      addedCurrentMatch = true

      if (successfulMatchedTokens.count != tokens.count) {
        if (let backtrack = attemptBacktrackMatch()) {
          return backtrack
        }
      }

      lastMatch = NodeTokenMatch(
        tokens: pattern.includeTokens ? successfulMatchedTokens.copy() : Token[],
        label: pattern.label,
        childMatches: childMatches.copy()
      )

      let acceptImmediately = targetParser.matcher.pattern.exact

      if (acceptImmediately) {
        log.traceFunc({"Contains exact match"})
      } else if (remainingPartialMatches) {
        log.traceFunc({"|
          Contains partial matches. Returning match and continuing
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            targetParser: #{targetParser.class.name}
            parsers: [#{currentParsers.filter(p => p != targetParser && p.matcher.partial).map(p => green(p.class.name)).join(", ", 50)}]
          |"})
      } else {
        log.traceFunc({"No partial matches"})
      }

      if (acceptImmediately || !targetParser.matcher.partial && !remainingPartialMatches) {
        if (let childParsers = targetParser.childParsers) {
          log.traceFunc({"Contains possible child matchers. Continuing with childParsers: [#{childParsers.map(p => green(p.class.name)).join(", ", 50)}]"})
          setCurrentParsers(childParsers)
          this.context = this.context.copy(annotations: Array())
          addedCurrentMatch = false
        } else if (attemptingBacktrack) {
          log.traceFunc({"No child matchers. Returning last match"})
        } else if (!targetParser || !targetParser.matcher.pattern.metadata) {
          if (pattern.statementEndToken) {
            log.traceFunc({"No child matchers. Returning last match and waiting for statement end token"})
          } else {
            log.traceFunc({"No child matchers. Returning last match and disqualified"})
            disqualified = true
          }
        } else {
          log.traceFunc({"No child matchers. Returning last match"})
        }

        if (targetParser?.matcher.pattern.metadata) {
          if (let metadataNode = targetParser.generateNode()) {
            context.addMetadata(metadataNode)
            setCurrentParsers(currentParsers.map({ _.copy() }))
            this.context = this.context.copy(annotations: Array())
            addedCurrentMatch = false
            log.traceFunc({"Added metadata node and reset parsers"})
          } else {
            log.warnFunc({"Failed to parse metadata node"})
          }
        } else {
          complete = true
        }
      } else {
        log.traceFunc({"Current targetParser is partial or has other remaining partial matches"})
      }
    } else {
      log.traceFunc({"|
        Matches are empty
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          currentParsers complete/disqualified/partial:
            [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
          childMatches:
            #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        |"})
      if (lastMatch) {
        log.traceFunc({"Has last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"|
            Contains partial matches. Continuing
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              targetParser: #{targetParser.class.name}
              parsers: [#{currentParsers.filter(p => p != targetParser && p.matcher.partial).map(p => green(p.class.name)).join(", ", 50)}]
              childMatches:
                #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            |"})
          return null
        } else {
          if (let statementEnd = checkStatementEnd(token, targetParser, targetMatch)) {
            return statementEnd
          }
          if (!pattern.parseChildren) {
            log.traceFunc({"Child parsing is disabled for pattern. Disqualified. Returning last match"})
            complete = lastParser.matcher.complete
            disqualified = true
          } else if (!lastParser) {
            log.traceFunc({"lastParser is null. Returning null"})
            return null
          } else {
            return attemptBacktrackMatch()
          }
        }
      } else {
        log.traceFunc({"Does not have last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"|
            Contains partial matches. Returning null
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              targetParser: #{targetParser.class.name}
              parsers: [#{currentParsers.filter(p => p != targetParser && p.matcher.partial).map(p => green(p.class.name)).join(", ", 50)}]
            |"})
          return null
        } else {
          log.traceFunc({"Never matched. Disqualified"})
          disqualified = true
          return null
        }
      }
    }

    log.traceFunc({"|
      Returning match at end of function
        tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        lastMatch.tokens: [#{lastMatch?.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
        currentParsers complete/disqualified/partial:
          [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
        childMatches:
          #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
      |"})

    return lastMatch
  }

  checkStatementEnd(Token token, ParserBase targetParser, TokenMatch targetMatch) -> NodeTokenMatch => null {
    if (pattern.statementEndToken && token.type == pattern.statementEndToken.type && token.value == pattern.statementEndToken.value) {
      disqualified = true
      log.traceFunc({"|
        Encountered statement end token. Returning match. Disqualified
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          lastMatch?.tokens: [#{lastMatch?.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
          currentParsers complete/disqualified/partial:
            [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
          childMatches:
            #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
          disqualified: #{disqualified}
          complete: #{complete}
          valid: #{valid}
        |"})

      if (lastMatch) {
        return lastMatch.copy(
          tokens: pattern.includeTokens ? tokens.copy() : Token[]
        )
      } else if (targetParser) {
        childMatches.add(
          NodeTokenMatchChild(
            tokens: targetMatch.tokens,
            parser: targetParser
          )
        )
        return NodeTokenMatch(
          tokens: pattern.includeTokens ? tokens.copy() : Token[],
          label: pattern.label,
          childMatches: childMatches.copy()
        )
      } else {
        log.traceFunc({"Failed to create match for statement end"})
      }
    }
  }

  attemptBacktrackMatch() -> NodeTokenMatch => null {
    log.traceFunc({"Attempting backtrack match with parser #{green(lastParser.class.name)}"})
    if (let childParsers = lastParser.childParsers) {
      log.traceFunc({"Setting currentParsers to childParsers from parser: #{lastParser.class.name}"})
      setCurrentParsers(childParsers)
      this.context = this.context.copy(annotations: Array())
      addedCurrentMatch = false
      complete = true
      let tokensToMatch = tokens.skip(successfulMatchedTokens.count)
      tokens = successfulMatchedTokens.copy()

      if (tokensToMatch.isNotEmpty) {
        log.traceFunc({"|
          All matchers are incomplete and disqualified. Attempting to parse further child nodes from last match
            successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            parser: #{lastParser.class.name}
          |"})

        attemptingBacktrack = true

        let continuationMatches = tokensToMatch.map((token) => {
          if (disqualified) {
            return null
          }
          NodeTokenMatcher.log.traceFunc({"|
            Matching continuation token '#{green(token.value)}'
              successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              childMatches:
                #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              parser: #{lastParser.class.name}
            |"})

          let value = this.match(token)

          NodeTokenMatcher.log.traceFunc({"|
            Finished matching continuation token '#{green(token.value)}'
              successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              childMatches:
                #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
              matchedTokens: #{value?.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              parser: #{lastParser.class.name}
              valid: #{valid}
              complete: #{complete}
            |"})

          return value
        })

        attemptingBacktrack = false

        if (let matchValue = continuationMatches.lastWhere({ _ != null })) {
          for (var Int i = continuationMatches.count - 1; i >= 0; i--) {
            if (continuationMatches[i] == null) {
              tokens.removeLast()
            }
          }

          log.traceFunc({"|
            Got a complete match from child parser. Returning match
              successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              childMatches:
                #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
              lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              matchValue.tokens: [#{matchValue.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              parser: #{lastParser.class.name}
              disqualified: #{disqualified}
              complete: #{complete}
              valid: #{valid}
            |"})

          return matchValue
        } else {
          log.traceFunc({"|
            Did not get a complete match from child parser
              successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              childMatches:
                #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
              lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
              parser: #{lastParser.class.name}
              currentParsers complete/disqualified/partial:
                [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
              disqualified: #{disqualified}
              complete: #{complete}
              valid: #{valid}
            |"})
          return null
        }
      } else {
        log.traceFunc({"|
          No more tokens to match.
            successfulMatchedTokens: [#{successfulMatchedTokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            childMatches:
              #{childMatches.map(m => green(m.parser.class.name) + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50) + "]").join("\n    ")}
            lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ", 50)}]
            parser: #{lastParser.class.name}
            currentParsers complete/disqualified/partial:
              [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ", 50)}]
            disqualified: #{disqualified}
            complete: #{complete}
            valid: #{valid}
          |"})
        if (currentParsers.any(p => p.matcher.partial)) {
          log.traceFunc({"Contains partial matches. Returning null"})
          return null
        }
      }
    } else {
      log.traceFunc({"No child matchers. Disqualified"})
    }

    disqualified = true
  }

  setCurrentParsers(ParserBase[] parsers) {
    currentParsers = parsers
    currentParsers.forEach({ _.context = context })
  }

  allParsersDisqualified() => currentParsers.all(p => !p.matcher.complete && p.matcher.disqualified)

  override public reset() {
    if (!dirty) return

    log.traceFunc({"Resetting matcher"})
    super.reset()

    childMatches = NodeTokenMatch[]
    lastMatch = null
    targetMatch = null
    lastTargetMatch = null
    context = null
    setCurrentParsers(pattern.parsers.map({ _.copy() }))
    attemptingBacktrack = false
    addedCurrentMatch = false
    successfulMatchedTokens = Token[]
  }
}