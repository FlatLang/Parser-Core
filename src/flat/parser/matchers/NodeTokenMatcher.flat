package flat/parser/matchers

import flat/parser
import flat/datastruct/HashMap
import flat/compiler/models/Token
import flat/log/Logger

import static flat/colorizer/Colorizer

data class extends TokenMatcher {
  static Logger log = Logger(NodeTokenMatcher.class)

  NodeTokenPattern pattern

  var ParseContext context
  var NodeTokenMatch lastMatch
  var NodeTokenMatchChild[] childMatches = NodeTokenMatchChild[]
  var ParserBase[] currentParsers
  var Bool attemptingBacktrack = false
  var Bool addedCurrentMatch = false

  override public match(Token token, ParseContext context = null) -> NodeTokenMatch {
    if (!this.context) {
      this.context = context?.copy(
        annotations: Array()
      )
    }
    if (!currentParsers) {
      currentParsers = pattern.parsers.forEach({ _.copy() })
    }

    tokens.add(token)

    return tokenMatches.add(doMatch(token))
  }

  doMatch(Token token) -> NodeTokenMatch {
    if (disqualified) return null
    log.traceFunc({"Matching token '#{green(token.value)}'"})

    var ParserBase matchParser
    let matchParsers = ParserBase[]
    let matches = TokenMatch[]

    for (parser in currentParsers) {
      if (parser.matcher.disqualified) continue
      log.traceFunc({"|
        Matching token '#{green(token.value)}' #{magenta(token.location?.lineNumber.toString())}:#{magenta(token.location?.column.toString())} against parser: #{green(parser.class.name)}
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        |"})
      if (let match = parser.match(token, context)) {
        log.traceFunc({"Matched token '#{green(token.value)}'"})
        matches.add(match)
        if (!matchParser || parser.acceptImmediately()) {
          matchParser = parser

          if (parser.acceptImmediately()) {
            break
          }
        }
        matchParsers.add(parser)
      } else if (parser.matcher.partial) {
        log.traceFunc({"Partial match for token '#{green(token.value)}'"})
      } else {
        log.traceFunc({"Didn't match token '#{green(token.value)}'"})
      }
      log.traceFunc({"|
        Finished matching token '#{green(token.value)}' against parser: #{green(parser.class.name)}
          tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        |"})
    }

    if (allParsersDisqualified() && childMatches.isNotEmpty) {
      if (attemptingBacktrack) {
        log.traceFunc({"Already attempting backtrack parse. Disqualified"})
        disqualified = true
        return null
      }

      let lastParser = childMatches.last.parser

      if (let childParsers = lastParser.childParsers) {
        log.traceFunc({"Setting currentParsers to childParsers from parser: #{lastParser.class.name}"})
        currentParsers = childParsers
        addedCurrentMatch = false
        complete = true
        let successfulTokens = childMatches.flatMap({ _.tokens })
        let tokensToMatch = tokens.skip(successfulTokens.count)
        tokens = successfulTokens

        if (tokensToMatch.isNotEmpty) {
          log.traceFunc({"|
            All matchers are incomplete and disqualified. Attempting to parse further child nodes from last match
              successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              childMatches:
                #{childMatches.map(m => m.parser.class.name + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ") + "]").join("\n    ")}
              lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
              childParsers: [#{childParsers.map(p => green(p.class.name)).join(", ")}]
              parser: #{lastParser.class.name}
            |"})

          attemptingBacktrack = true

          let continuationMatches = tokensToMatch.map((token) => {
            NodeTokenMatcher.log.traceFunc({"|
              Matching continuation token '#{green(token.value)}'
                successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                childMatches:
                  #{childMatches.map(m => m.parser.class.name + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ") + "]").join("\n    ")}
                tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
                parser: #{lastParser.class.name}
              |"})

            let value = this.match(token)

            NodeTokenMatcher.log.traceFunc({"|
              Finished matching continuation token '#{green(token.value)}'
                successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                childMatches:
                  #{childMatches.map(m => m.parser.class.name + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ") + "]").join("\n    ")}
                matchedTokens: #{value?.tokens.map(t => "'" + green(t.value) + "'").join(", ")}
                tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
                parser: #{lastParser.class.name}
              |"})

            return value
          })

          attemptingBacktrack = false

          if (let matchValue = continuationMatches.lastWhere({ _ != null })) {
            log.traceFunc({"|
              Got a complete match from child parser. Returning match
                successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                childMatches:
                  #{childMatches.map(m => m.parser.class.name + ": " + "[" + m.tokens.map(t => "'" + green(t.value) + "'").join(", ") + "]").join("\n    ")}
                lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
                matchValue.tokens: [#{matchValue.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                parser: #{lastParser.class.name}
                childParsers: [#{childParsers.map(p => green(p.class.name)).join(", ")}]
                disqualified: #{disqualified}
                complete: #{complete}
                valid: #{valid}
              |"})
            return matchValue
          } else {
            log.traceFunc({"|
              Did not get a complete match from child parser
                successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
                tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
                parser: #{lastParser.class.name}
                currentParsers complete/disqualified/partial:
                  [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ")}]
                disqualified: #{disqualified}
                complete: #{complete}
                valid: #{valid}
              |"})
            if (currentParsers.any(p => p.matcher.partial)) {
              log.traceFunc({"Contains partial matches. Returning null"})
              return null
            }
          }
        } else {
          log.traceFunc({"|
            No more tokens to match.
              successfulTokens: [#{successfulTokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              lastMatch.tokens: [#{lastMatch.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              tokens: [#{tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
              tokensToMatch: [#{tokensToMatch.map(t => "'" + green(t.value) + "'").join(", ")}]
              parser: #{lastParser.class.name}
              currentParsers complete/disqualified/partial:
                [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ")}]
              disqualified: #{disqualified}
              complete: #{complete}
              valid: #{valid}
            |"})
          if (currentParsers.any(p => p.matcher.partial)) {
            log.traceFunc({"Contains partial matches. Returning null"})
            return null
          }
        }
      }

      disqualified = true

      return null
    }

    valid = true

    let remainingPartialMatches = currentParsers.any(p => p != matchParser && p.matcher.partial)

    if (matches.isNotEmpty) {
      log.traceFunc({"|
        Contains matches for parser: #{green(matchParser.class.name)}
          #{matchParsers.map(m => magenta(m.pattern.toPatternString())).join("\n  ")}
        |"})
      complete = matchParser.matcher.complete && currentParsers.none({ _.matcher.partial })

      if (addedCurrentMatch) {
        let childTokens = pattern.includeTokens ?
          tokens.skip(lastMatch ? lastMatch.tokens.count - childMatches.last.tokens.count : 0) :
          Token[]

        log.traceFunc({"Replacing last match"})
        childMatches.replaceLast(
          NodeTokenMatchChild(
            tokens: childTokens,
            parser: matchParser
          )
        )
      } else {
        let childTokens = pattern.includeTokens ?
          tokens.skip(lastMatch ? lastMatch.tokens.count : 0) :
          Token[]

        log.traceFunc({"Adding last match"})
        childMatches.add(
          NodeTokenMatchChild(
            tokens: childTokens,
            parser: matchParser
          )
        )
      }
      addedCurrentMatch = true

      let acceptImmediately = matchParser.acceptImmediately()

      lastMatch = NodeTokenMatch(
        tokens: pattern.includeTokens ? tokens.copy() : Token[],
        label: pattern.label,
        childMatches: childMatches.copy()
      )

      if (acceptImmediately) {
        log.traceFunc({"Contains exact match"})
      } else if (remainingPartialMatches) {
        log.traceFunc({"Contains partial matches. Returning match and continuing"})
      } else {
        log.traceFunc({"No partial matches"})
      }

      complete = true

      if (acceptImmediately || !matchParser.matcher.partial && !remainingPartialMatches) {
        if (let childParsers = matchParser.childParsers) {
          log.traceFunc({"Contains possible child matchers. Continuing with childParsers: [#{childParsers.map(p => green(p.class.name)).join(", ")}]"})
          currentParsers = childParsers
          addedCurrentMatch = false
        } else if (attemptingBacktrack) {
          log.traceFunc({"No child matchers. Returning last match"})
        } else if (!matchParser || !matchParser.isMetadata) {
          log.traceFunc({"No child matchers. Returning last match and disqualified"})
          disqualified = true
        } else {
          log.traceFunc({"No child matchers. Returning last match"})
        }

        if (matchParser?.isMetadata) {
          if (let metadataNode = matchParser.generateNode(context, matchParser.lastMatch)) {
            context.addMetadata(metadataNode)
            currentParsers = pattern.parsers.map({ _.copy() })
            addedCurrentMatch = false
            log.traceFunc({"Added metadata node and reset parsers"})
          } else {
            log.warnFunc({"Failed to parse metadata node"})
          }
        }
      } else {
        log.traceFunc({"Current matchParser is partial or has other remaining partial matches"})
      }
    } else {
      log.traceFunc({"Matches are empty"})
      if (lastMatch) {
        log.traceFunc({"Has last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"Contains partial matches. Continuing"})
          return null
        } else {
          let lastParser = childMatches.last?.parser

          if (!pattern.parseChildren) {
            log.traceFunc({"Child parsing is disabled for pattern. Disqualified. Returning last match"})
            complete = lastParser.matcher.complete
            disqualified = true
          } else if (!lastParser) {
            log.traceFunc({"lastParser is null. Returning null"})
            return null
          } else {
            if (let childParsers = lastParser.childParsers) {
              log.traceFunc({"Matching child parsers for parser #{green(lastParser.class.name)}"})
              currentParsers = childParsers
              addedCurrentMatch = false
              return doMatch(token)
            } else {
              log.traceFunc({"No more partial matches and no child parsers. Disqualified"})
              complete = lastParser.matcher.complete
              disqualified = true
              return null
            }
          }
        }
      } else {
        log.traceFunc({"Does not have last match"})
        if (remainingPartialMatches) {
          log.traceFunc({"Contains partial matches. Returning null"})
          return null
        } else {
          log.traceFunc({"Never matched. Disqualified"})
          disqualified = true
          return null
        }
      }
    }

    log.traceFunc({"|
      Returning match at end of function
        lastMatch.tokens: [#{lastMatch?.tokens.map(t => "'" + green(t.value) + "'").join(", ")}]
        currentParsers complete/disqualified/partial:
          [#{currentParsers.map(p => green(p.class.name) + ":" + p.matcher.complete + "/" + p.matcher.disqualified + "/" + p.matcher.partial).join(", ")}]
        disqualified: #{disqualified}
        complete: #{complete}
        valid: #{valid}
      |"})

    return lastMatch
  }

  allParsersDisqualified() => currentParsers.all(p => !p.matcher.complete && p.matcher.disqualified)

  override public reset() {
    if (!dirty) return

    log.traceFunc({"Resetting matcher"})
    super.reset()

    childMatches = NodeTokenMatch[]
    lastMatch = null
    context = null
    currentParsers = pattern.parsers.map({ _.copy() })
    addedCurrentMatch = false
  }
}