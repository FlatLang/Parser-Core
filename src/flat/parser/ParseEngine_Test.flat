package flat/parser

import flat/parser/flat
import flat/parser/matchers
import flat/annotations
import flat/compiler/models
import flat/ast
import flat/stream/Stream
import flat/io/File

testable class {
  test `can consume a token`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))

    expect(engine.getPartialMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  test `can find a package match`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(engine.getPartialMatches().mapNotNull({ _.lastMatch })).toBe([
      GroupTokenMatch(
        tokens: [
          Token(value: "package", type: Token.Type.IDENTIFIER),
          Token(value: "test", type: Token.Type.IDENTIFIER)
        ],
        tokenMatches: [
          SingleTokenMatch(
            tokens: [Token(value: "package", type: Token.Type.IDENTIFIER)]
          ),
          SingleTokenMatch(
            tokens: [Token(value: "test", type: Token.Type.IDENTIFIER)],
            label: "package_location_component"
          )
        ]
      )
    ])
  }

  test `does not return package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(engine.getPartialMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  test `returns valid package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(engine.getCompletedMatches().mapNotNull({ _.lastMatch })).toBe([
      GroupTokenMatch(
        tokens: [
          Token(value: "package", type: Token.Type.IDENTIFIER),
          Token(value: "test", type: Token.Type.IDENTIFIER)
        ],
        tokenMatches: [
          SingleTokenMatch(
            tokens: [Token(value: "package", type: Token.Type.IDENTIFIER)]
          ),
          SingleTokenMatch(
            tokens: [Token(value: "test", type: Token.Type.IDENTIFIER)],
            label: "package_location_component"
          )
        ]
      )
    ])

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(engine.getPartialMatches().mapNotNull({ _.lastMatch })).toBe(Array())
  }

  test `emits node after valid package match once the next token breaks the parser matcher`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    var Node node = null

    stream.on<Node>("data", { node = _ })$

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(node).toBe(PackageNode(location: "test"))
  }

  test `can parse full package before creating node`() {
    let fileNode = FileNode(file: File("Test.flat"))
    let fileParser = FileParser()
    let fileScopeParser = FileScopeParser()
    let stream = Stream(true)
    let engine = ParseEngine(fileNode, fileParser, fileScopeParser, FlatParseContext(), stream)

    var Node node = null

    stream.on<Node>("data", { node = _ })$

    engine.consume(Token(value: "package", type: Token.Type.IDENTIFIER))
    engine.consume(Token(value: "test", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "/", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "test2", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "/", type: Token.Type.SYMBOL))
    engine.consume(Token(value: "test3", type: Token.Type.IDENTIFIER))

    expect(node).toBe(null)

    engine.consume(Token(value: "import", type: Token.Type.IDENTIFIER))

    expect(node).toBe(PackageNode(location: "test/test2/test3"))
  }
}
