package flat/parser

import flat/parser/matchers
import flat/ast/Node
import flat/compiler/models/Token

abstract data class {
  ParserBase[] childParsers => null

  visible Bool isMetadata => false

  visible lazy TokenPattern pattern => null
  visible lazy TokenMatcher matcher => pattern?.getMatcher()

  public var TokenMatch lastMatch <=> lastMatch
  public var ParseContext context <=> context

  public abstract generateNode() -> Node
  public generateNodes() => Array<Node>():add(this.generateNode())
  public getChildNodeTokenMatches() => NodeTokenMatch[]

  public matchAll(Token[] tokens) -> TokenMatch[] => tokens.map({ this.match(_) })

  public match(Token token) -> TokenMatch => null {
    if (!matcher) return null
    if (context && !Object.referenceEquals(context.currentParser, this)) {
      context = context.copy(
        parserStack: context.parserStack.copy():push(this)
      )
    }

    if (let match = matcher.match(token, context))  {
      return lastMatch = match
    }
  }

  public reset() {
    lastMatch = null

    if (pattern) {
      matcher.reset()
    }
  }
}